# 动态配置扫描根目录功能实现计划（修改版）

## 问题分析
当前系统通过配置文件的`app.scan.root-dirs`属性指定扫描根目录，存在以下问题：
- 使用`@Value`注解直接注入配置，无法动态修改
- 修改配置后必须重启前后端服务，操作繁琐
- 缺乏直观的用户界面进行配置管理

## 解决方案设计
1. **提供REST API**：允许前端获取和更新根目录配置
2. **修改现有服务**：使其支持动态根目录配置
3. **在现有界面添加配置**：在Header区域添加根目录显示和修改功能
4. **自动触发扫描**：配置修改后自动重新扫描

## 实现步骤

### 1. 后端实现

#### 1.1 创建配置REST API控制器
```java
// ConfigController.java
@RestController
@RequestMapping("/api/v1/config")
public class ConfigController {
    
    private String currentRootDirs;
    
    // 从配置文件初始化根目录
    @Value("${app.scan.root-dirs}")
    public void setInitialRootDirs(String rootDirs) {
        this.currentRootDirs = rootDirs;
    }
    
    // 获取当前根目录配置
    @GetMapping("/root-dirs")
    public ResponseEntity<String> getRootDirs() {
        return ResponseEntity.ok(currentRootDirs);
    }
    
    // 更新根目录配置
    @PutMapping("/root-dirs")
    public ResponseEntity<Void> updateRootDirs(@RequestBody String rootDirs) {
        this.currentRootDirs = rootDirs;
        return ResponseEntity.ok().build();
    }
}
```

#### 1.2 修改FileScanServiceImpl.java
```java
@Service
public class FileScanServiceImpl implements FileScanService {
    
    // 删除@Value注解，改为动态获取
    private String rootDirs;
    
    @Value("${app.scan.root-dirs}")
    public void setInitialRootDirs(String rootDirs) {
        this.rootDirs = rootDirs;
    }
    
    // 添加更新根目录的方法
    public void updateRootDirs(String newRootDirs) {
        this.rootDirs = newRootDirs;
    }
    
    // 其他方法保持不变
}
```

#### 1.3 修改ConfigController.java，添加FileScanService依赖
```java
@RestController
@RequestMapping("/api/v1/config")
public class ConfigController {
    
    private final FileScanServiceImpl fileScanService;
    
    @Autowired
    public ConfigController(FileScanServiceImpl fileScanService) {
        this.fileScanService = fileScanService;
    }
    
    @PutMapping("/root-dirs")
    public ResponseEntity<Void> updateRootDirs(@RequestBody String rootDirs) {
        fileScanService.updateRootDirs(rootDirs);
        return ResponseEntity.ok().build();
    }
    
    // 其他方法保持不变
}
```

#### 1.4 修改其他服务类
修改以下服务类，将`@Value("${app.scan.root-dirs}")`替换为动态获取方式：
- FileController.java
- AdvancedSearchService.java
- SimpleSearchService.java
- PreviewServiceImpl.java

### 2. 前端实现

#### 2.1 修改App.jsx，添加根目录配置功能
在Header的header-actions区域添加根目录显示和修改功能：

```jsx
// App.jsx 中添加状态
const [rootDirs, setRootDirs] = useState('');
const [isEditing, setIsEditing] = useState(false);
const [tempRootDirs, setTempRootDirs] = useState('');

// 添加获取根目录配置的函数
const fetchRootDirs = useCallback(async () => {
    try {
        const response = await fetch('/api/v1/config/root-dirs');
        if (response.ok) {
            const data = await response.text();
            setRootDirs(data);
            setTempRootDirs(data);
        }
    } catch (err) {
        console.error('Failed to fetch root dirs:', err);
    }
}, []);

// 添加更新根目录配置的函数
const handleUpdateRootDirs = useCallback(async () => {
    try {
        const response = await fetch('/api/v1/config/root-dirs', {
            method: 'PUT',
            headers: {
                'Content-Type': 'text/plain'
            },
            body: tempRootDirs
        });
        if (response.ok) {
            setRootDirs(tempRootDirs);
            setIsEditing(false);
            notification.success({ 
                message: '配置更新成功', 
                description: '根目录配置已更新，将自动触发扫描', 
                placement: 'bottomRight', 
                duration: 3 
            });
            // 自动触发扫描
            handleScan();
        }
    } catch (err) {
        console.error('Failed to update root dirs:', err);
        notification.error({ 
            message: '配置更新失败', 
            description: err.message, 
            placement: 'bottomRight', 
            duration: 3 
        });
    }
}, [tempRootDirs, handleScan]);

// 在useEffect中调用fetchRootDirs
useEffect(() => {
    fetchRootDirs();
}, [fetchRootDirs]);

// 修改Header部分
<Header className="header">
    <div className="logo">Nexus-Lite 知识预览系统</div>
    <div className="header-actions">
        {/* 添加根目录配置 */}
        <Space style={{ marginRight: 16 }}>
            {isEditing ? (
                <>
                    <Input
                        size="small"
                        value={tempRootDirs}
                        onChange={(e) => setTempRootDirs(e.target.value)}
                        placeholder="请输入扫描根目录"
                        style={{ width: 200 }}
                    />
                    <Space>
                        <Button size="small" onClick={handleUpdateRootDirs}>保存</Button>
                        <Button size="small" onClick={() => {
                            setIsEditing(false);
                            setTempRootDirs(rootDirs);
                        }}>取消</Button>
                    </Space>
                </>
            ) : (
                <Space>
                    <span style={{ color: '#fff', marginRight: 8 }}>根目录: {rootDirs}</span>
                    <Button size="small" onClick={() => setIsEditing(true)}>修改</Button>
                </Space>
            )}
        </Space>
        
        {/* 原有的强制扫描按钮 */}
        <Button
            danger
            icon={<ReloadOutlined />}
            onClick={handleScan}
            loading={loading}
        >
            强制扫描
        </Button>
    </div>
</Header>
```

### 3. 功能测试
1. 启动应用，访问首页
2. 在Header区域查看当前根目录配置
3. 点击"修改"按钮，修改根目录配置
4. 点击"保存"按钮，验证配置是否成功更新
5. 验证系统是否自动重新扫描
6. 验证文件访问是否使用新的根目录

## 预期效果
- 用户可以在现有界面直观修改扫描根目录
- 配置修改后立即生效，无需重启服务
- 自动触发重新扫描，确保索引与新配置一致
- 提供配置验证，防止无效路径

## 技术要点
- 后端使用简单的内存存储动态配置
- 前端使用React hooks管理状态
- 遵循RESTful API设计规范
- 在现有界面中无缝集成配置功能

## 风险评估
- 配置错误可能导致文件扫描失败，需要添加验证机制
- 频繁修改配置可能导致多次扫描，需要添加防抖处理
- 权限控制：确保只有授权用户可以修改配置

## 后续优化
- 支持多根目录配置
- 添加配置验证和错误提示
- 实现配置持久化存储