# kg-agent 知识图谱增强检索单体服务实施规划

## 1. 项目背景与目标

### 1.1 项目背景
基于《知识图谱全文检索单体服务改造方案.md》设计文档，将原微服务架构的“知识图谱全文检索系统”改造为适合单台服务器部署的单体服务架构。本项目（代号：kg-agent）旨在实现一个集成全文检索、向量检索和图谱检索的GraphRAG（图谱增强检索）系统。

### 1.2 核心目标
1. **降低运维复杂度**：从多微服务架构简化为单体应用+本地服务组件
2. **保持核心技术能力**：保留GraphRAG核心能力（知识抽取、混合检索、图谱推理）
3. **简化部署**：通过`docker-compose up`一键部署，适合中小规模企业内部部署
4. **与现有系统集成**：作为Nexus-Lite文档预览系统的增强模块，提供知识图谱和高级检索能力

### 1.3 范围界定
- **包含**：Python Flask后端服务、Celery异步任务、多存储组件集成、GraphRAG核心算法
- **不包含**：前端UI界面（复用现有React前端）、用户认证系统（可扩展）
- **部署模式**：单体服务，运行在单台服务器上，支持Docker容器化部署

## 2. 整体架构设计

### 2.1 架构图概览
```
用户 -> [React前端] -> [Nginx反向代理] -> [单体后端服务]
                                      |
                                      +-> [异步任务队列] -> [Celery Worker]
                                      |
                                      +-> [本地存储组件] (ES, Milvus, Nebula, Redis, 文件系统)
```

### 2.2 核心组件
1. **Flask主应用**：统一API入口，包含Search/KG/Admin三大蓝图
2. **Celery异步任务**：文档处理流水线，运行NLP模型和向量编码
3. **存储组件**：
   - Elasticsearch（单节点）：全文检索
   - Milvus Lite/FAISS：向量检索
   - NebulaGraph（单机版）：知识图谱存储
   - Redis：缓存和消息队列
   - 本地文件系统/MinIO：文档存储
4. **处理流水线**：文本提取 -> NLP处理 -> 向量编码 -> 图谱构建

### 2.3 技术栈选型
| 组件 | 选型 | 版本 | 说明 |
|------|------|------|------|
| Web框架 | Flask | 3.0.x | 轻量级，蓝图支持好 |
| 异步任务 | Celery | 5.3+ | 成熟的任务队列系统 |
| 向量模型 | BGE-M3 | 最新 | 中文支持好，多向量能力 |
| 向量存储 | Milvus Lite | 2.3+ | 嵌入式，无需独立服务 |
| 全文检索 | Elasticsearch | 8.x | 单节点部署 |
| 图数据库 | NebulaGraph | 3.x | 单机Docker版 |
| 缓存/队列 | Redis | 7.x | 消息队列+缓存 |
| API文档 | Flasgger | 最新 | OpenAPI 3.0支持 |
| 配置管理 | Pydantic Settings | 2.4+ | 类型安全的配置管理 |
| ORM/ODM | 各客户端库 | - | 不使用统一ORM |

## 3. 实施阶段规划

### 阶段一：项目初始化与环境搭建
**目标**：创建kg-agent目录结构，建立Python开发环境，配置基础依赖

**关键任务**：
1. **创建项目根目录**：在`/lite-webviewer`下新建`kg-agent`目录
2. **Python环境配置**：
   - 创建`pyproject.toml`（Poetry）管理依赖
   - 定义开发和生产依赖
   - 配置开发工具（pytest, black, flake8, mypy）
3. **基础目录结构创建**：
   ```
   kg-agent/
   ├── src/
   │   └── backend/
   │       ├── app/
   │       │   ├── __init__.py
   │       │   ├── api/           # API蓝图（Search, KG, Admin）
   │       │   ├── services/      # 业务逻辑层
   │       │   ├── models/        # 数据模型（Pydantic）
   │       │   ├── tasks/         # Celery任务定义
   │       │   └── utils/         # 工具类
   │       ├── config.py          # 统一配置（Pydantic Settings）
   │       └── main.py            # Flask应用入口
   ├── tests/                     # 单元测试
   ├── docker/                    # Docker相关文件
   ├── docs/                      # 项目文档
   ├── .env.example               # 环境变量示例
   ├── .gitignore                 # Git忽略文件
   ├── pyproject.toml             # 依赖管理
   ├── README.md                  # 项目说明
   └── docker-compose.dev.yml     # 开发环境Docker Compose
   ```
4. **基础配置文件**：
   - 应用配置类（基于环境变量）
   - 日志配置（结构化JSON日志）
   - 开发环境docker-compose（基础服务）

**交付物**：
- `kg-agent`目录结构
- `pyproject.toml`依赖文件
- 基础配置类和日志系统
- 开发环境docker-compose文件

**依赖关系**：无

### 阶段二：核心模块实现
**目标**：实现基础服务层、工具类和领域模型

**关键任务**：
1. **配置管理模块**：
   - 基于Pydantic Settings的配置类
   - 支持环境变量和配置文件优先级
   - 配置验证和类型安全
2. **日志系统**：
   - 结构化JSON日志格式
   - 不同日志级别配置
   - 请求ID追踪
3. **工具类模块**：
   - 文件处理工具（本地/MinIO适配器接口）
   - 文本处理工具（分块、清洗、编码检测）
   - 缓存装饰器（Redis + 内存LRU缓存）
   - 健康检查工具
4. **领域模型**（Pydantic）：
   - 文档模型：`Document`, `Chunk`, `Metadata`
   - 检索模型：`SearchQuery`, `SearchResult`, `SearchResponse`
   - 图谱模型：`Entity`, `Relation`, `GraphQuery`, `GraphResult`
   - 任务模型：`TaskStatus`, `TaskResult`
5. **错误处理框架**：
   - 自定义异常类
   - 统一异常处理器
   - HTTP错误响应格式化

**交付物**：
- 配置管理模块
- 完整的工具类集合
- 领域模型定义
- 错误处理框架

**依赖关系**：阶段一完成

### 阶段三：API层实现
**目标**：实现Flask应用和三大API蓝图

**关键任务**：
1. **Flask应用初始化**：
   - 应用工厂模式
   - 扩展注册（CORS，OpenAPI）
   - 蓝本注册机制
2. **API蓝图划分**：
   - `search_blueprint` (`/api/search/*`): 全文检索、混合检索
   - `kg_blueprint` (`/api/kg/*`): 知识图谱查询、实体关系探索
   - `admin_blueprint` (`/api/admin/*`): 系统管理、索引重建、状态监控
3. **请求/响应模型**：
   - Pydantic定义API Schema
   - 请求验证和序列化
   - 响应模型嵌套支持
4. **OpenAPI文档**：
   - Flasgger配置
   - 自动生成Swagger UI
   - 路由注解和示例
5. **API端点实现**：
   - 健康检查端点
   - 系统状态端点
   - 占位实现（后续填充业务逻辑）
6. **中间件**：
   - 请求日志中间件
   - 认证中间件（预留）
   - 限流中间件（预留）

**交付物**：
- 完整的Flask应用
- 三大API蓝本骨架
- OpenAPI文档
- 基础API端点

**依赖关系**：阶段二完成

### 阶段四：异步任务系统（Celery）
**目标**：实现文档处理流水线，支持异步任务执行

**关键任务**：
1. **Celery配置**：
   - Redis作为消息代理和结果后端
   - 任务序列化配置（JSON）
   - 重试策略和错误处理
2. **任务定义模块**：
   - 基础任务类（带状态追踪）
   - 文档提取任务（PDF, DOCX, Markdown等格式支持）
   - 文本分块任务（RecursiveCharacterTextSplitter，512 tokens）
   - 向量编码任务（BGE-M3模型加载和推理）
   - 图谱构建任务（实体识别、关系抽取）
   - 索引构建任务（多存储同步）
3. **任务流水线**：
   - 链式任务执行
   - 任务组和和弦
   - 错误处理和重试机制
4. **Worker进程管理**：
   - 并发数配置（CPU核心数-1）
   - 模型懒加载和共享内存
   - 资源限制和监控
5. **任务监控**：
   - 任务状态查询API
   - Flower监控集成（可选）
   - 任务结果存储

**交付物**：
- Celery配置和任务定义
- 文档处理流水线
- Worker部署配置
- 任务监控接口

**依赖关系**：阶段三完成（需要API端点）

### 阶段五：存储组件集成
**目标**：集成各存储组件，实现数据持久化和检索

**关键任务**：
1. **Elasticsearch集成**：
   - 单节点Docker部署配置
   - 索引模板设计（文本分块、元数据字段映射）
   - 中文分词配置（ik插件，自定义词库）
   - 检索DSL构建器（BM25评分、混合打分函数）
   - 索引管理API（创建、更新、删除）
2. **向量存储集成**：
   - 方案评估：Milvus Lite vs FAISS
   - 向量索引配置（IVF_FLAT或HNSW）
   - 向量相似度计算（余弦相似度、L2距离）
   - 批量向量操作接口
3. **图数据库集成**：
   - NebulaGraph单机版Docker部署
   - 图Schema设计（顶点类型、边类型、属性）
   - nGQL查询构建器
   - 图遍历算法封装
   - 子图查询和路径发现
4. **缓存集成**：
   - Redis客户端封装
   - 多级缓存策略（内存LRU + Redis）
   - 缓存装饰器和失效策略
5. **文件存储适配器**：
   - 统一存储接口
   - 本地文件系统实现
   - MinIO/S3适配器（可选）
   - 文件分块上传和断点续传

**交付物**：
- 各存储组件的客户端封装
- 索引和Schema定义
- 统一数据访问层接口
- 存储健康检查

**依赖关系**：阶段四完成（需要任务系统处理数据）

### 阶段六：GraphRAG核心逻辑
**目标**：实现知识图谱增强检索的核心算法

**关键任务**：
1. **文本处理流水线**：
   - 多格式文档解析器（PDF, DOCX, TXT, Markdown）
   - 语义分块算法（重叠窗口，语义边界检测）
   - 向量编码服务（BGE-M3模型集成，1024维向量）
   - 元数据提取（作者、时间、关键词）
2. **混合检索引擎**：
   - **三路检索策略**：
     - 全文检索（ES）：关键词匹配，BM25评分
     - 向量检索（Milvus）：语义相似度，余弦距离
     - 图谱检索（Nebula）：实体链接，关系推理
   - **结果融合算法**：
     - Reciprocal Rank Fusion (RRF)
     - 加权评分融合（可配置权重）
     - 去重和多样性控制
   - **相关性优化**：
     - BM25参数调优
     - 向量归一化处理
     - 图谱置信度评分
3. **查询理解模块**：
   - 意图识别（规则引擎 + 轻量级BERT）
   - 查询扩展（同义词库、实体链接）
   - 实体识别和关系提取
   - 图遍历查询生成（nGQL语句自动构建）
4. **RAG生成模块**：
   - 检索结果上下文组装
   - 提示工程模板
   - 生成结果后处理
   - 引用和溯源标注
5. **知识图谱构建**：
   - 实体识别（NER模型）
   - 关系抽取（预定义关系类型）
   - 图谱更新和增量构建
   - 图谱质量评估

**交付物**：
- 完整的GraphRAG处理流水线
- 混合检索引擎实现
- 查询理解模块
- 知识图谱构建工具

**依赖关系**：阶段五完成（需要存储组件可用）

### 阶段七：部署与运维
**目标**：实现容器化部署，配置生产环境

**关键任务**：
1. **Docker化配置**：
   - Flask应用Dockerfile（Python 3.11，多阶段构建）
   - Celery Worker Dockerfile（模型预加载优化）
   - Nginx配置（反向代理 + 静态文件服务）
2. **Docker Compose编排**：
   ```yaml
   services:
     flask_app:     # Flask Web服务（端口5000）
     celery_worker: # 异步任务处理
     redis:        # 缓存和消息队列（端口6379）
     elasticsearch: # 单节点ES（端口9200）
     nebula:       # 单机版NebulaGraph（端口9669, 9559）
     milvus:       # Milvus Lite（端口19530，可选）
     nginx:        # 反向代理（端口80/443）
   ```
3. **环境配置管理**：
   - 环境变量优先级配置
   - 敏感信息管理（Secret）
   - 配置文件模板
4. **健康检查配置**：
   - 各组件健康检查端点
   - 就绪和存活探针
   - 依赖关系检查
5. **日志收集配置**：
   - 结构化日志输出
   - 日志轮转策略
   - ELK集成配置（可选）
6. **监控告警配置**：
   - Prometheus指标暴露
   - 关键业务指标监控
   - 告警规则定义

**交付物**：
- 生产环境Dockerfile
- docker-compose.prod.yml
- 部署脚本和文档
- 监控和日志配置

**依赖关系**：阶段六完成（核心功能可用）

### 阶段八：测试与优化
**目标**：确保系统稳定性和性能

**关键任务**：
1. **测试策略实施**：
   - 单元测试（pytest）：核心算法和工具类
   - 集成测试：存储组件连通性
   - API测试（pytest-flask）：端点功能和错误处理
   - 性能测试：并发处理和响应时间
2. **性能优化**：
   - 索引优化：ES分片设置，刷新间隔调整
   - 查询优化：nGQL查询剪枝，LIMIT控制
   - 缓存优化：热点数据识别，缓存策略调整
   - 连接池优化：数据库连接复用
3. **资源管理优化**：
   - 内存控制：模型懒加载，大对象管理
   - CPU优化：任务并发控制，批量处理
   - 磁盘IO：索引文件优化，日志轮转
4. **安全加固**：
   - 输入验证和过滤
   - API速率限制
   - 敏感信息保护
5. **文档完善**：
   - API文档更新
   - 部署运维手册
   - 故障排查指南

**交付物**：
- 完整的测试套件
- 性能优化报告
- 生产就绪检查清单
- 完整项目文档

**依赖关系**：阶段七完成（部署配置就绪）

## 4. 与现有系统集成方案

### 4.1 架构关系
现有Nexus-Lite系统（Java Spring Boot）与kg-agent的关系：

```
[用户浏览器]
     |
[React前端] (http://localhost:5173)
     |
[Nginx反向代理] (http://localhost:80)
     |                    |
     |-- /api/* (大部分) --> [Spring Boot] (8080)
     |-- /api/search/advanced --> [kg-agent Flask] (5000)
     |-- /api/kg/* ----------> [kg-agent Flask] (5000)
     |-- /api/admin/kg/* ---> [kg-agent Flask] (5000)
```

### 4.2 数据流集成
1. **文档同步**：
   - 方案A：共享文件系统，kg-agent监听文件变化
   - 方案B：通过API同步文档元数据
   - 方案C：定期全量同步

2. **用户请求路由**：
   - 基础搜索：仍由Spring Boot处理
   - 高级搜索（向量/图谱）：由kg-agent处理
   - 知识图谱查询：由kg-agent处理

3. **状态一致性**：
   - 索引状态同步
   - 任务状态查询
   - 系统健康状态聚合

### 4.3 API兼容性
- 保持现有API接口不变
- 新增API前缀为`/api/search/advanced`和`/api/kg/`
- 提供API版本控制（`/api/v1/kg/`）

## 5. 风险管理与缓解措施

### 5.1 技术风险
| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 存储组件资源竞争 | 性能下降 | 中 | 资源限制配置，监控告警 |
| 模型内存占用高 | 服务崩溃 | 中 | 模型懒加载，Worker内存限制 |
| 数据一致性难题 | 检索结果不一致 | 低 | 事务性操作，定期一致性检查 |
| 中文分词效果差 | 检索准确率低 | 低 | 自定义词库，多分词器对比 |

### 5.2 实施风险
| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 阶段依赖延迟 | 项目延期 | 中 | 并行任务，最小可行产品 |
| 技术选型不当 | 重构成本 | 低 | 技术验证，备选方案 |
| 团队技能不足 | 实现质量低 | 低 | 文档完善，代码审查 |

### 5.3 运维风险
| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 单点故障 | 服务中断 | 中 | 健康检查，自动恢复 |
| 数据备份缺失 | 数据丢失 | 低 | 定期备份，快照策略 |
| 监控覆盖不全 | 问题发现延迟 | 中 | 完善监控，日志聚合 |

## 6. 成功标准与验收条件

### 6.1 功能验收标准
1. ✅ 支持多格式文档上传和解析
2. ✅ 实现三路混合检索（全文+向量+图谱）
3. ✅ 提供知识图谱查询和可视化
4. ✅ 支持异步批量文档处理
5. ✅ 提供完整的API文档
6. ✅ 一键Docker部署

### 6.2 性能验收标准
1. ⏱️ 单次检索响应时间 < 2秒（P95）
2. ⏱️ 文档处理吞吐量 > 10文档/分钟
3. 💾 内存占用 < 8GB（包含所有组件）
4. 💾 存储需求可配置，支持TB级文档

### 6.3 质量验收标准
1. ✅ 单元测试覆盖率 > 80%
2. ✅ API测试覆盖率 > 90%
3. ✅ 文档完整性和准确性
4. ✅ 安全漏洞扫描通过

## 7. 后续演进规划

### 7.1 短期优化（3个月内）
1. 向量模型优化（量化、蒸馏）
2. 缓存策略精细化
3. 监控告警完善

### 7.2 中期扩展（3-6个月）
1. 多租户支持
2. 插件化架构
3. 分布式部署支持

### 7.3 长期演进（6-12个月）
1. 多模态检索支持
2. 自适应学习优化
3. 云原生架构改造

---

## 附录

### A. 开发环境要求
- Python 3.11+
- Docker & Docker Compose
- Redis 7.x
- Elasticsearch 8.x
- NebulaGraph 3.x
- 至少16GB内存（开发环境）
- 至少50GB磁盘空间

### B. 团队角色与职责
- **架构师**：技术选型，架构设计
- **后端开发**：核心功能实现
- **算法工程师**：检索算法优化
- **运维工程师**：部署和监控
- **测试工程师**：质量保障

### C. 关键里程碑
1. **M1**（2周）：项目初始化完成，基础环境就绪
2. **M2**（4周）：核心模块和API骨架完成
3. **M3**（6周）：异步任务系统就绪
4. **M4**（8周）：存储组件集成完成
5. **M5**（10周）：GraphRAG核心逻辑实现
6. **M6**（12周）：部署配置完成，测试通过
7. **M7**（14周）：生产就绪，文档完善

### D. 变更记录
| 版本 | 日期 | 修改内容 | 修改人 |
|------|------|----------|--------|
| 1.0 | 2025-12-03 | 初始版本 | Claude Code |

---

**审批签字**：
- 项目经理：___________________ 日期：___________
- 技术负责人：___________________ 日期：___________
- 产品负责人：___________________ 日期：___________